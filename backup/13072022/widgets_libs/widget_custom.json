{
  "widgetsBundle": {
    "alias": "widget_custom2",
    "title": "Widget-custom",
    "image": null,
    "description": null
  },
  "widgetTypes": [
    {
      "alias": "update_state",
      "name": "Công đoạn lắp ráp",
      "descriptor": {
        "type": "latest",
        "sizeX": 8.5,
        "sizeY": 7,
        "resources": [
          {
            "url": "https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css"
          }
        ],
        "templateHtml": "<div class=\"m-2 row\">\n    <div class=\"col-6\">\n        <b>Tên sản phẩm: </b>{{productName}}<br>\n        <b>Mã sản phẩm: </b>{{productCode}}<br>\n        <b>Lưu ý sản xuất:</b>\n    </div>\n    <div class=\"col-6\">\n        <b>Lệnh sản xuất: </b>{{productName}}<br>\n        <b>Số lô: </b>{{productCode}}<br>\n    </div>\n    <h2 class=\"text-center\">Danh sách khai báo lỗi</h2>\n    <!--<div class=\"text-center\">-->\n    <!--    <button class=\"w-25 btn btn-info\">Serial</button>-->\n    <!--</div>-->\n    <form *ngIf=\"claimDeviceFormGroup\" #claimDeviceForm=\"ngForm\" [formGroup]=\"claimDeviceFormGroup\"\n      tb-toast toastTarget=\"{{ toastTargetId }}\"\n      class=\"claim-form mt-2\" (ngSubmit)=\"claim()\">\n        <mat-form-field appearance=\"outline\" class=\"mat-block w-50\">\n                        <mat-label>Serial</mat-label>\n                            <input matInput type=\"text\" formControlName=\"serial\" />\n                        <!--<mat-error *ngIf=\"claimDeviceFormGroup.get('deviceName').hasError('required')\">-->\n                        <!--    {{requiredErrorDevice}}-->\n                        <!--</mat-error>-->\n                    </mat-form-field>\n        <div class=\"row border\">\n            <div class=\"col-6 mt-1\" formArrayName=\"errors\" *ngFor=\"let error of errors().controls; let i=index\">\n                <fieldset class=\"d-flex justify-content-around\" *ngIf=\"i>=pageStart && i<pageEnd\" [disabled]=\"(isLoading$ | async) || loading\">\n                    <button class=\"mt-2\" mat-fab type=\"button\" (click)=\"subtractValue(i)\" color=\"warn\" aria-label=\"Example icon button with a heart icon\">\n                            -\n                        </button>\n                    <mat-form-field appearance=\"outline\" class=\"mat-block w-50\">\n                        <mat-label>{{relation[i].label}}</mat-label>\n                            <input matInput type=\"number\" [formControlName]=\"i\" required />\n                        <!--<mat-error *ngIf=\"claimDeviceFormGroup.get('deviceName').hasError('required')\">-->\n                        <!--    {{requiredErrorDevice}}-->\n                        <!--</mat-error>-->\n                        <mat-error *ngIf=\"claimDeviceFormGroup.get('errors').controls[i].invalid\">Min: 0</mat-error>\n                    </mat-form-field>\n                        <button class=\"mt-2\" mat-fab type=\"button\" (click)=\"addValue(i)\" color=\"warn\" aria-label=\"Example icon button with a heart icon\">\n                            +\n                        </button>\n                        \n    \n                </fieldset>\n            </div>\n        </div>\n        <div class=\"mat-block mt-2\" fxLayout=\"row\" fxLayoutAlign=\"end center\">\n            <button mat-button mat-raised-button color=\"primary\"\n                type=\"submit\" [disabled]=\"(isLoading$ | async)\">\n                Xác nhận\n            </button>\n        </div>\n    </form>\n    <mat-paginator [length]=\"allErrorLength\"\n                  [pageSize]=\"6\"\n                  [pageSizeOptions]=\"[6, 12, 24]\"\n                  aria-label=\"Select page\"\n                  (page)=\"onPageChange($event)\">\n    </mat-paginator>\n</div>",
        "templateCss": ".attribute-update-form {\n    overflow: hidden;\n    height: 100%;\n    display: flex;\n    flex-direction: column;\n}\n\n.attribute-update-form__grid {\n    display: flex;\n}\n.grid__element:first-child {\n    flex: 1;\n}\n.grid__element:last-child {\n    margin-top: 19px;\n    margin-left: 7px;\n}\n.grid__element {\n    display: flex;\n}\n\n.attribute-update-form .mat-button.mat-icon-button {\n    width: 32px;\n    min-width: 32px;\n    height: 32px;\n    min-height: 32px;\n    padding: 0 !important;\n    margin: 0 !important;\n    line-height: 20px;\n}\n\n.attribute-update-form .mat-icon-button mat-icon {\n    width: 20px;\n    min-width: 20px;\n    height: 20px;\n    min-height: 20px;\n    font-size: 20px;\n}\n\n.tb-toast {\n    font-size: 14px!important;\n}",
        "controllerScript": "let $scope;\nlet settings;\nlet attributeService;\nlet utils;\nlet translate;\nlet entityRelationService;\nlet assetService;\nself.onInit = function() {\n    self.ctx.ngZone.run(function() {\n        init();\n        self.ctx.detectChanges(true);\n    });\n};\n\n\nfunction init() {\n\n    $scope = self.ctx.$scope;\n    attributeService = $scope.$injector.get(self.ctx\n        .servicesMap.get('attributeService'));\n    assetService = $scope.$injector.get(self.ctx\n        .servicesMap.get('assetService'));\n    entityRelationService = $scope.$injector.get(self.ctx\n        .servicesMap.get('entityRelationService'));\n    utils = $scope.$injector.get(self.ctx.servicesMap.get(\n        'utils'));\n    translate = $scope.$injector.get(self.ctx.servicesMap\n        .get('translate'));\n    $scope.toastTargetId = 'input-widget' + utils.guid();\n    settings = utils.deepClone(self.ctx.settings) || {};\n    settings.showLabel = utils.defaultValue(settings\n        .showLabel, true);\n    settings.showResultMessage = utils.defaultValue(settings\n        .showResultMessage, true);\n    $scope.settings = settings;\n    $scope.isValidParameter = true;\n    $scope.dataKeyDetected = false;\n    $scope.pageStart = 0;\n    $scope.pageEnd = 6;\n    $scope.requiredErrorMessage = utils.customTranslation(\n        settings.requiredErrorMessage, settings\n        .requiredErrorMessage) || translate.instant(\n        'widgets.input-widgets.entity-attribute-required'\n    );\n    $scope.labelValue = utils.customTranslation(settings\n            .labelValue, settings.labelValue) || translate\n        .instant('widgets.input-widgets.value');\n\n    $scope.attributeUpdateFormGroup = $scope.fb.group({\n        currentValue: [undefined, [$scope.validators\n            .required,\n            $scope.validators.min(settings\n                .minValue),\n            $scope.validators.max(settings\n                .maxValue)\n        ]],\n    });\n\n    $scope.claimDeviceFormGroup = $scope.fb.group({\n        deviceName: [0],\n        serial: [''],\n        errors: $scope.fb.array([])\n    });\n    if ($scope.secretKeyField) {\n        $scope.claimDeviceFormGroup.addControl(\n            'deviceSecret', $scope.fb.control('', [\n                $scope.validators.required\n            ]));\n    }\n\n    if (self.ctx.datasources && self.ctx.datasources\n        .length) {\n        console.log(\"self.ctx.datasources: \", self.ctx\n            .datasources);\n        var datasource = self.ctx.datasources[0];\n        if (datasource.type === 'entity') {\n            if (datasource.entityType && datasource\n                .entityId) {\n                $scope.entityName = datasource.entityName;\n                if (settings.widgetTitle && settings\n                    .widgetTitle.length) {\n                    $scope.titleTemplate = utils\n                        .customTranslation(settings\n                            .widgetTitle, settings\n                            .widgetTitle);\n                } else {\n                    $scope.titleTemplate = self.ctx\n                        .widgetConfig.title;\n                }\n\n                $scope.entityDetected = true;\n            }\n        }\n        if (datasource.dataKeys.length) {\n            if (datasource.dataKeys[0].type !==\n                \"attribute\") {\n                $scope.isValidParameter = false;\n            } else {\n                $scope.currentKey = datasource.dataKeys[0]\n                    .name;\n                $scope.dataKeyType = datasource.dataKeys[0]\n                    .type;\n                $scope.dataKeyDetected = true;\n            }\n        }\n    }\n\n    self.ctx.widgetTitle = utils.createLabelFromDatasource(\n        self.ctx.datasources[0], $scope.titleTemplate);\n    console.log(utils.createLabelFromDatasource(self.ctx\n        .datasources[0], $scope.titleTemplate));\n    console.log(\"datasources: \", self.ctx.data);\n    $scope.data = self.ctx.data;\n    if ($scope.data[0].data.length > 0) {\n        $scope.productName = $scope.data[0].data[0][1];\n        $scope.productCode = $scope.data[1].data[0][1];\n        $scope.entityId = $scope.data[0].datasource.entity\n            .id;\n        console.log(\"entityId:\", $scope.entityId);\n        $scope.relation = [];\n        $scope.allErrorLength = 0;\n        // $scope.errorFormArray = $scope.fb.array([]);\n        entityRelationService.findInfoByFrom($scope\n            .entityId).subscribe(data => {\n            console.log(\"data: \", data);\n            attributeService\n                .getEntityTimeseriesLatest($scope\n                    .entityId, ['errors',\n                        'total_hmi_error'\n                    ]).subscribe(error => {\n                    console.log(\"errors: \", JSON\n                        .parse(error.errors[\n                            0].value));\n                    const oldErrors = error\n                        .errors[0].value ? JSON\n                        .parse(error.errors[0]\n                            .value) : [];\n                    $scope.total_hmi_error =\n                        error.total_hmi_error ?\n                        error.total_hmi_error[0]\n                        .value : 0;\n                    var assetIds = []\n                    data.map(d => {\n                        if (d.to\n                            .entityType ==\n                            \"ASSET\" && d\n                            .type ==\n                            \"machine_asset_error\"\n                        ) {\n                            console.log(\"d: \", d);\n                            assetIds.push(d.to.id);\n                            $scope\n                                .relation\n                                .push(d\n                                    .toName\n                                );\n                            let oldValue =\n                                0;\n                            Object.keys(\n                                    oldErrors\n                                )\n                                .map(\n                                    oldErr => {\n                                        if (d\n                                            .toName ==\n                                            oldErr\n                                        )\n                                            oldValue =\n                                            oldErrors[\n                                                oldErr\n                                            ];\n                                    });\n                            $scope.allErrorLength++;\n                            $scope.errors()\n                                .push(\n                                    $scope\n                                    .fb\n                                    .control(\n                                        oldValue,\n                                        [$scope\n                                            .validators\n                                            .required,\n                                            $scope\n                                            .validators\n                                            .min(\n                                                0\n                                            )\n                                        ]\n                                    )\n                                );\n                        }\n                    });\n                    assetService.getAssets(assetIds).subscribe((data) => $scope.relation = data);\n                });\n\n\n            // $scope.claimDeviceFormGroup.addControl('errors', $scope.errorFormArray);\n\n            console.log(\n                \"$scope.errors().controls: \",\n                $scope.errors().controls);\n        });\n        console.log(\"$scope.relation: \", $scope.relation);\n\n\n        // $scope.personMobile = $scope.data.data[0][1];\n        // $scope.name = self.ctx.data[2].data[0][1];\n    }\n    $scope.errors = function() {\n        return $scope.claimDeviceFormGroup.get(\n            'errors');\n    }\n\n    // $scope.attributeUpdateFormGroup.get('name').patchValue(self.ctx.data[0].data[0]);\n\n    $scope.claim = function() {\n        console.log(\"clai: \", $scope\n            .claimDeviceFormGroup.get('errors')\n            .value);\n        let errorNumbers = $scope.claimDeviceFormGroup\n            .get('errors').value;\n        let errors = {};\n        let totalErrors = 0;\n        errorNumbers.forEach((e, index) => {\n            // errors.push({\n            //     \"key\": $scope.relation[index],\n            //     \"value\": e\n            // });\n            errors[$scope.relation[index].name] = e;\n            totalErrors += e;\n        });\n        console.log(\"errors: \", errors);\n        var totalerrors = parseInt(totalErrors) + (\n                    $scope.total_hmi_error ?\n                    parseInt($scope\n                        .total_hmi_error) : 0);\n        let attributesArray = [{\n                key: \"errors\",\n                value: errors\n            },\n            {\n                key: \"total_common_error\",\n                value: totalErrors\n            },\n            {\n                key: 'totalerrors',\n                value: totalerrors\n            }\n        ]\n        \n        entityRelationService.findInfoByTo($scope.entityId).subscribe(data => \n        {\n            console.log(\"line: \", data);\n            entityRelationService.findInfoByTo(data[0].from).subscribe(d => {\n                console.log(\"Wo_Line: \", d);\n                const saveParts = {\n                    key: $scope.entityName,\n                    value: JSON.stringify(attributesArray)\n                };\n                console.log(JSON.stringify(attributesArray));\n                console.log(\"saveParts: \", saveParts);\n                var parts = [];\n                var totalErrorsWoLine = 0;\n                    attributeService.getEntityTimeseriesLatest(d[0].from, ['parts']).subscribe(data => {\n                        console.log(\"parts: \", data);\n                        parts = data.parts ? JSON.parse(data.parts[0].value): [];\n                        if(parts.length > 0) {\n                            let existPart = false;\n                            parts = parts.map(part => {\n                                if(part.key != $scope.entityName) {\n                                    let valuePart = JSON.parse(part.value);\n                                    valuePart.map(attr => {\n                                        if(attr.key == \"totalerrors\")\n                                            totalErrorsWoLine = totalErrorsWoLine + parseInt(attr.value);\n                                    });\n                                    return part;\n                                } else {\n                                    existPart = true;\n                                    totalErrorsWoLine = totalErrorsWoLine + totalerrors;\n                                    return saveParts;\n                                }\n                            });\n                            console.log(\"existPart: \", existPart);\n                            if(!existPart)\n                                parts.push(saveParts);\n                        } else {\n                            totalErrorsWoLine = totalErrorsWoLine + totalerrors;\n                            parts.push(saveParts);\n                        }\n                        \n                        attributeService.saveEntityTimeseries(d[0].from, \"SERVER_SCOPE\", [{\n                            key: 'parts',\n                            value: JSON.stringify(parts)\n                        },\n                        {\n                            key: \"totalErrorsWoLine\",\n                            value: totalErrorsWoLine\n                        }\n                        ]).subscribe(part => {\n                            console.log(\"part: \", part);\n                        })\n                    })\n                });\n                \n            });\n        // attributeService.saveEntityAttributes($scope.entityId, \"SERVER_SCOPE\", attributesArray).subscribe((data) => {\n        //     alert(\"Success\");\n        // })\n        \n        \n\n        attributeService.saveEntityTimeseries($scope\n            .entityId, \"SERVER_SCOPE\",\n            attributesArray).subscribe(\n            (data) => {\n                $scope.showSuccessToast(\n                    \"Update Successful\", 2000,\n                    'bottom', 'left', $scope\n                    .toastTargetId);\n\n            },\n            () => {\n                $scope.showErrorToast(\n                    \"Update Failed\", 'bottom',\n                    'left', $scope.toastTargetId\n                );\n            }\n        )\n\n    }\n    $scope.onPageChange = function(event) {\n        console.log(\"Event: \", event);\n        $scope.pageStart = event.pageIndex * event\n            .pageSize;\n        $scope.pageEnd = (event.pageIndex + 1) * event\n            .pageSize;\n\n    }\n    $scope.subtractValue = function(i) {\n        $scope.claimDeviceFormGroup.get('errors')\n            .controls[i].patchValue($scope\n                .claimDeviceFormGroup.get('errors')\n                .controls[i].value - 1);\n\n    }\n    $scope.addValue = function(i) {\n        $scope.claimDeviceFormGroup.get('errors')\n            .controls[i].patchValue($scope\n                .claimDeviceFormGroup.get('errors')\n                .controls[i].value + 1);\n    }\n    $scope.updateAttribute = function(index, Wo_Id,\n        Lot_Number, Line_Id, Product_Code) {\n        var param = {};\n        param.Cmd = index;\n        param.Wo_Id = Wo_Id;\n        param.Lot_Number = Lot_Number;\n        param.Line_Id = Line_Id;\n        param.Product_Code = Product_Code;\n        $scope.isFocused = false;\n        if ($scope.entityDetected) {\n            var datasource = self.ctx.datasources[0];\n\n            attributeService.saveEntityAttributes(\n                datasource.entity.id,\n                'SERVER_SCOPE',\n                [{\n                    key: $scope.currentKey,\n                    value: index\n                }]\n            ).subscribe(\n                function success() {\n                    $scope.originalValue = $scope\n                        .attributeUpdateFormGroup\n                        .get('currentValue').value;\n                    if (settings\n                        .showResultMessage) {\n                        $scope.showSuccessToast(\n                            translate.instant(\n                                'widgets.input-widgets.update-successful'\n                            ), 1000,\n                            'bottom', 'left',\n                            $scope.toastTargetId\n                        );\n                    }\n                },\n                function fail() {\n                    if (settings\n                        .showResultMessage) {\n                        $scope.showErrorToast(\n                            translate.instant(\n                                'widgets.input-widgets.update-failed'\n                            ), 'bottom',\n                            'left', $scope\n                            .toastTargetId);\n                    }\n                }\n            );\n        }\n    };\n\n}\n\nfunction correctValue(value) {\n    if (typeof value !== \"number\") {\n        return 0;\n    }\n    return value;\n}\n\nself.onResize = function() {\n\n}\n\n// self.typeParameters = function() {\n//     return {\n//         maxDatasources: ,\n//         maxDataKeys: 1,\n//         singleEntity: true\n//     }\n// }\n\nself.onDestroy = function() {\n\n}",
        "settingsSchema": "{\n    \"schema\": {\n        \"type\": \"object\",\n        \"title\": \"EntitiesTableSettings\",\n        \"properties\": {\n            \"widgetTitle\": {\n                \"title\": \"Widget title\",\n                \"type\": \"string\",\n                \"default\": \"\"\n            },\n            \"showLabel\":{\n                \"title\":\"Show label\",\n                \"type\":\"boolean\",\n                \"default\":true\n            },\n            \"name\": {\n              \"title\": \"name\",\n              \"type\": \"string\",\n              \"default\": \"\"\n            },\n            \"labelValue\": {\n                \"title\": \"Label\",\n                \"type\": \"string\",\n                \"default\": \"\"\n            },\n            \"requiredErrorMessage\": {\n                \"title\": \"'Required' error message\",\n                \"type\": \"string\",\n                \"default\": \"\"\n            },\n            \"maxValue\": {\n                \"title\": \"Max value\",\n                \"type\": \"number\",\n                \"default\": \"\"\n            },\n            \"minValue\": {\n                \"title\": \"Min value\",\n                \"type\": \"number\",\n                \"default\": \"\"\n            },\n            \"showResultMessage\":{\n                \"title\":\"Show result message\",\n                \"type\":\"boolean\",\n                \"default\":true\n            }\n        },\n        \"required\": []\n    },\n    \"form\": [\n        \"widgetTitle\",\n        \"showResultMessage\",\n        \"showLabel\",\n        \"name\",\n        \"labelValue\",\n        \"requiredErrorMessage\",\n        \"maxValue\",\n        \"minValue\"\n    ]\n}",
        "dataKeySettingsSchema": "{}\n",
        "defaultConfig": "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"entityAliasId\":null,\"filterId\":null,\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Random\",\"color\":\"#2196f3\",\"settings\":{},\"_hash\":0.15479322438769105,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < -1000) {\\n\\tvalue = -1000;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"}]}],\"timewindow\":{\"realtime\":{\"timewindowMs\":60000}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{\"showResultMessage\":true,\"showLabel\":true},\"title\":\"Công đoạn lắp ráp\",\"dropShadow\":true,\"enableFullscreen\":false,\"widgetStyle\":{},\"titleStyle\":{\"fontSize\":\"16px\",\"fontWeight\":400},\"useDashboardTimewindow\":true,\"showLegend\":false,\"actions\":{}}"
      },
      "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAACgCAAAAABslHx1AAAAAmJLR0QA/4ePzL8AAANMSURBVHja7d3fS5NRGAfw/SsrhSCKKIugburCi6KCLrropi4izME0c1kLUxquHybmKNPAi4qMJkm9hOkswhVkpaLMfhmlbjHYu+3Vaf7a3r3fLjad5nZh6NiZ3+diO+fAe/HhOc85Z+/Fjg4R2T0ieLjlMHQRT0iF4KGGPBGdHEIWREjWudVsgKhu3QiyIkYIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQghZS8jbbwDQOT9slJc/5HGJAOmoAaAUjKWERCO9z7RI5kPGC8cBxy3A5/wUBoyy1qNirg+I9jtlAPBcvGkt7xWgRmyvgKpu9JR3NF4HjHLk9DSCBmi2eqnsFwCEK8vGRSj2j9fgM85h0Ito4VgC0m/R4GwEgHZ72xMRIOHiwIv7wJ/HN6oKfAmIdL62tsoCAMps1CvE8vuwvWIIaHgehTEGmULQgPYGv9+vCLWP/Cg1a4ClG18LvDDKKPmJPgNGzwXgdQkF0S5JAPrPXqgzDcAo402R2WYAukorzUMi7uzR6YWqmY0BJzQeUQghhBBC1h9kZllDDIj2cumBaKZaijWk6hmRIFqLybl0RDJJi75EgWitJse/Y20mKf4hDkRrWe4AJJOUPB8ZC0mWj1hOUjgyDjJ9zw1Ae5rcsUKIbK9rmVzovatv+hJvfh5ec4hirfidYl6teGp1bd1/Km9XfDhasOnksZxGAIGmA/rWtU/J2NXL7tT5WEmxz+0sUqHsNsR69lwXcDc3AC13b0U6IFCsZanzsZLld1D/AYApP/5wDYBBfTfwPupPCwSKNbnj/zbE44WLOvYcLwCkCYLpVTyiODb2zDe/P7qypQnphKzioXF0myUxMw9t3+MUFBLcd2LxP1qo1bnDQkKmjhydWjqw4YGIkMiJ/MT5ufggAL9eEhCilWzudLlcLgWvbYBDfyfoPpOnCAiZ1MeiGeYdKtCcp9cfHhB11YoXeewFo2+Cv9kJIYQQQghZf5DbaQ1mhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCEkMyFZc0FwdlzZPC7rwtlxibaqy45rzVX8BUWnY6Q1/jMIAAAAAElFTkSuQmCC",
      "description": "Simple form to input new double value for pre-defined server-side attribute key."
    },
    {
      "alias": "multi_series_pie32",
      "name": "Total Error Pie",
      "descriptor": {
        "type": "latest",
        "sizeX": 9,
        "sizeY": 8.5,
        "resources": [
          {
            "url": "https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-datalabels/2.0.0/chartjs-plugin-datalabels.min.js",
            "isModule": false
          },
          {
            "url": "https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.6.0/chart.min.js"
          }
        ],
        "templateHtml": "<canvas id=\"pieChart\"></canvas>",
        "templateCss": "",
        "controllerScript": "let data;\nlet ChartDataLabels;\nself.onInit = function() {\n    console.log(\"Self.ctx.data: ---->\", self.ctx.data);\n    console.log(\"Self.ctx.datasource: ------>\", self.ctx.datasources);\n    const partData = self.ctx.data;\n    data = {\n        labels: [\n        ],\n        datasets: [{\n            label: 'My First Dataset',\n            data: [],\n            backgroundColor: [\n            ],\n            hoverOffset: 4\n        }]\n    };\n    \n    \n    \n    if(partData[0].data.length > 0) {\n        if(partData[0].data[0][1] != \"\") {\n            const parts = JSON.parse(partData[0].data[0][1]);\n            for(var i=0; i<parts.length; i++) {\n                data.labels.push(parts[i].key);\n                let value = JSON.parse(parts[i].value);\n                value.map(attr => {\n                    if(attr.key ==\"totalerrors\")\n                        data.datasets[0].data.push(parseInt(attr.value));\n                })\n                // data.datasets[0].data.push(partData[i+1].data[0][1]);\n                data.datasets[0].backgroundColor.push(\"#\" + Math.floor(Math.random()*16777215).toString(16));\n        }\n    //     for(var i=0; i< partData.length; i+=2) {\n    //         data.labels.push(partData[i].data[0][1]);\n    //         data.datasets[0].data.push(partData[i+1].data[0][1]);\n    //         data.datasets[0].backgroundColor.push(\"#\" + Math.floor(Math.random()*16777215).toString(16));\n    //     }\n        }\n    }\n    // console.log(\"Data pie chart: \", data);\n\n    // console.log(\"Data multiSeriesChart: \", self.ctx\n    //     .data);\n    // if (self.ctx.data[0].data.length > 0) {\n    //     console.log(\"AAAAAAAAAAA\");\n    //     var numberOfOutput = parseFloat(self.ctx.data[0]\n    //         .data[0][1]) ? parseFloat(self.ctx.data[\n    //             0]\n    //         .data[0][1]) : 0;\n    //     var numberOfPlanning = parseFloat(self.ctx.data[\n    //             1]\n    //         .data[0][1]) ? parseFloat(self.ctx.data[\n    //             1]\n    //         .data[0][1]) : 0;\n    //     var runningTime = parseFloat(self.ctx.data[2]\n    //         .data[0][1]) ? parseFloat(self.ctx.data[\n    //             2]\n    //         .data[0][1]) : 0;\n    //     var planningTime = parseFloat(self.ctx.data[3]\n    //         .data[0][1]) ? parseFloat(self.ctx.data[\n    //             3]\n    //         .data[0][1]) : 0;\n    //     var totalNumber = (numberOfPlanning +\n    //         numberOfOutput) != 0 ? (\n    //         numberOfPlanning +\n    //         numberOfOutput) : 1;\n    //     var totalTime = (runningTime +\n    //         planningTime) != 0 ? (runningTime +\n    //         planningTime) : 1;\n    //     data.datasets[0].data.push(numberOfOutput /\n    //         totalNumber * 100);\n    //     data.datasets[0].data.push(numberOfPlanning /\n    //         totalNumber * 100);\n    //     data.datasets[1].data.push(runningTime /\n    //         totalTime * 100);\n    //     data.datasets[1].data.push(planningTime /\n    //         totalTime * 100);\n\n    // }\n    // console.log(data);\n\n    // const config = {\n    //     type: 'doughnut',\n    //     data: data,\n    //     plugins: [ChartDataLabels ? ChartDataLabels: ''],\n    //     options: {\n    //         responsive: false,\n    //         maintainAspectRatio: false,\n    //         plugins: {\n    //             datalabels: {\n    //                 display: true,\n    //                 formatter: (value) => {\n    //                     return Math.round(\n    //                             value * 100) /\n    //                         100 + '%';\n    //                 },\n    //                 color: \"#fff\"\n    //             },\n\n    //             legend: {\n    //                 labels: {\n    //                     display: true,\n    //                     generateLabels: function(\n    //                         chart) {\n    //                         // Get the default label list\n    //                         const original =\n    //                             Chart.overrides\n    //                             .pie.plugins\n    //                             .legend.labels\n    //                             .generateLabels;\n    //                         const\n    //                             labelsOriginal =\n    //                             original.call(\n    //                                 this, chart\n    //                             );\n\n    //                         // Build an array of colors used in the datasets of the chart\n    //                         let datasetColors =\n    //                             chart.data\n    //                             .datasets.map(\n    //                                 function(\n    //                                     e) {\n    //                                     return e\n    //                                         .backgroundColor;\n    //                                 });\n    //                         datasetColors =\n    //                             datasetColors\n    //                             .flat();\n\n    //                         // Modify the color and hide state of each label\n    //                         labelsOriginal\n    //                             .forEach(\n    //                                 label => {\n    //                                     // There are twice as many labels as there are datasets. This converts the label index into the corresponding dataset index\n    //                                     label\n    //                                         .datasetIndex =\n    //                                         (label\n    //                                             .index -\n    //                                             label\n    //                                             .index %\n    //                                             2\n    //                                         ) /\n    //                                         2;\n\n    //                                     // The hidden state must match the dataset's hidden state\n    //                                     label\n    //                                         .hidden = !\n    //                                         chart\n    //                                         .isDatasetVisible(\n    //                                             label\n    //                                             .datasetIndex\n    //                                         );\n\n    //                                     // Change the color to match the dataset\n    //                                     label\n    //                                         .fillStyle =\n    //                                         datasetColors[\n    //                                             label\n    //                                             .index\n    //                                         ];\n    //                                 });\n\n    //                         const chartTitle =\n    //                             labelsOriginal\n    //                             .filter(\n    //                                 function(\n    //                                     value,\n    //                                     index,\n    //                                     arr) {\n    //                                     if (index ==\n    //                                         0) {\n    //                                         value\n    //                                             .text =\n    //                                             \"Sản lượng\";\n    //                                         return value;\n    //                                     }\n    //                                     if (index ==\n    //                                         2) {\n    //                                         value\n    //                                             .text =\n    //                                             \"Thời gian\";\n    //                                         return value;\n    //                                     }\n    //                                 })\n    //                         console.log(\n    //                             labelsOriginal\n    //                         )\n    //                         return chartTitle;\n    //                     }\n    //                 },\n    //                 onClick: function(mouseEvent,\n    //                     legendItem, legend) {\n    //                     // toggle the visibility of the dataset from what it currently is\n    //                     legend.chart\n    //                         .getDatasetMeta(\n    //                             legendItem\n    //                             .datasetIndex\n    //                         ).hidden = legend\n    //                         .chart\n    //                         .isDatasetVisible(\n    //                             legendItem\n    //                             .datasetIndex);\n    //                     legend.chart.update();\n    //                 }\n    //             },\n    //             tooltip: {\n    //                 callbacks: {\n    //                     label: function(context) {\n    //                         const labelIndex = (\n    //                                 context\n    //                                 .datasetIndex *\n    //                                 2) + context\n    //                             .dataIndex;\n    //                         return context.chart\n    //                             .data.labels[\n    //                                 labelIndex\n    //                             ] + ': ' +\n    //                             context\n    //                             .formattedValue;\n    //                     }\n    //                 }\n    //             }\n    //         }\n    //     }\n    // };\n    const config = {\n        type: 'pie',\n        data: data,\n        options: {\n            responsive: false,\n            maintainAspectRatio: false\n        }\n    };\n    var ctx = $('#pieChart', self.ctx\n        .$container);\n    self.ctx.chart = new Chart(ctx, config);\n    self.onResize();\n}\n\nself.onDataUpdated = function() {\n    data.labels = [];\n    data.datasets[0].data = [];\n    data.datasets[0].backgroundColor = [];\n    const partData = self.ctx.data;\n        if(partData[0].data.length > 0) {\n                    if(partData[0].data[0][1] != \"\") {\n\n        const parts = JSON.parse(partData[0].data[0][1]);\n        for(var i=0; i<parts.length; i++) {\n            data.labels.push(parts[i].key);\n            let value = JSON.parse(parts[i].value);\n            value.map(attr => {\n                if(attr.key ==\"totalerrors\")\n                    data.datasets[0].data.push(parseInt(attr.value));\n            })\n            // data.datasets[0].data.push(partData[i+1].data[0][1]);\n            data.datasets[0].backgroundColor.push(\"#\" + Math.floor(Math.random()*16777215).toString(16));\n        }\n    //     for(var i=0; i< partData.length; i+=2) {\n    //         data.labels.push(partData[i].data[0][1]);\n    //         data.datasets[0].data.push(partData[i+1].data[0][1]);\n    //         data.datasets[0].backgroundColor.push(\"#\" + Math.floor(Math.random()*16777215).toString(16));\n    //     }\n                    }\n    }\n    // var data1 = [];\n    // var data2 = [];\n    // console.log(\"Data multiSeriesChart: \", self.ctx\n    //     .data);\n    // if (self.ctx.data[0].data.length > 0) {\n    //     console.log(\"AAAAAAAAAAA\");\n    //     var numberOfOutput = parseFloat(self.ctx.data[0]\n    //         .data[0][1]) ? parseFloat(self.ctx.data[\n    //             0]\n    //         .data[0][1]) : 0;\n    //     var numberOfPlanning = parseFloat(self.ctx.data[\n    //             1]\n    //         .data[0][1]) ? parseFloat(self.ctx.data[\n    //             1]\n    //         .data[0][1]) : 0;\n    //     var runningTime = parseFloat(self.ctx.data[2]\n    //         .data[0][1]) ? parseFloat(self.ctx.data[\n    //             2]\n    //         .data[0][1]) : 0;\n    //     var planningTime = parseFloat(self.ctx.data[3]\n    //         .data[0][1]) ? parseFloat(self.ctx.data[\n    //             3]\n    //         .data[0][1]) : 0;\n    //     var totalNumber = (numberOfPlanning +\n    //         numberOfOutput) != 0 ? (\n    //         numberOfPlanning +\n    //         numberOfOutput) : 1;\n    //     var totalTime = (runningTime +\n    //         planningTime) != 0 ? (runningTime +\n    //         planningTime) : 1;\n    //     const data1 = [numberOfOutput / totalNumber *\n    //         100,\n    //         numberOfPlanning / totalNumber * 100\n    //     ];\n    //     const data2 = [runningTime /\n    //         totalTime * 100,\n    //         planningTime /\n    //         totalTime * 100\n    //     ];\n    //     data.datasets[0].data = data1;\n    //     data.datasets[1].data = data2;\n\n    // }\n    // // console.log(\"Self data ctx: \", self.ctx.data);\n    // // for (var i = 0; i < self.ctx.data.length; i++) {\n    // //     var cellData = self.ctx.data[i];\n    // //     if (cellData.data.length > 0) {\n    // //         var decimals;\n    // //         if (typeof cellData.dataKey.decimals !== 'undefined' \n    // //             && cellData.dataKey.decimals !== null ) {\n    // //             decimals = cellData.dataKey.decimals; \n    // //         } else {\n    // //             decimals = self.ctx.decimals;\n    // //         }\n    // //         var tvPair = cellData.data[cellData.data.length - 1];\n    // //         var value = self.ctx.utils.formatValue(tvPair[1], decimals);\n    // //         self.ctx.chart.data.datasets[0].data[i] = parseFloat(value);\n    // //     }\n    // // }\n    self.ctx.chart.update();\n\n}\n\nself.onResize = function() {\n    self.ctx.chart.resize();\n}",
        "settingsSchema": "{\n    \"schema\": {\n        \"type\": \"object\",\n        \"title\": \"Settings\",\n        \"properties\": {\n            \"borderWidth\": {\n                \"title\": \"Border width\",\n                \"type\": \"number\",\n                \"default\": 5\n            },\n            \"borderColor\": {\n                \"title\": \"Border color\",\n                \"type\": \"string\",\n                \"default\": \"#fff\"\n            },\n            \"legend\": {\n                \"title\": \"Legend settings\",\n                \"type\": \"object\",\n                \"properties\": {\n                    \"display\": {\n                        \"title\": \"Display legend\",\n                        \"type\": \"boolean\",\n                        \"default\": true\n                    },\n                    \"labelsFontColor\": {\n                        \"title\": \"Labels font color\",\n                        \"type\": \"string\",\n                        \"default\": \"#666\"\n                    }\n                }\n            }\n        },\n        \"required\": []\n    },\n    \"form\": [\n        \"borderWidth\", \n        {\n            \"key\": \"borderColor\",\n            \"type\": \"color\"\n        }, \n        {\n            \"key\": \"legend\",\n            \"items\": [\n                \"legend.display\",\n                {\n                    \"key\": \"legend.labelsFontColor\",\n                    \"type\": \"color\"\n                }\n            ]\n        }\n    ]\n}",
        "dataKeySettingsSchema": "{}\n",
        "defaultConfig": "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"First\",\"color\":\"#26a69a\",\"settings\":{},\"_hash\":0.15479322438769105,\"funcBody\":\"var value = (prevValue-50) + Math.random() * 2 - 1;\\nif (value < 0) {\\n\\tvalue = 0;\\n} else if (value > 100) {\\n\\tvalue = 100;\\n}\\nreturn value+50;\"},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Second\",\"color\":\"#f57c00\",\"settings\":{},\"_hash\":0.545701115289893,\"funcBody\":\"var value = (prevValue-20) + Math.random() * 2 - 1;\\nif (value < 0) {\\n\\tvalue = 0;\\n} else if (value > 100) {\\n\\tvalue = 100;\\n}\\nreturn value+20;\"},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Third\",\"color\":\"#afb42b\",\"settings\":{},\"_hash\":0.2592906835158064,\"funcBody\":\"var value = (prevValue-40) + Math.random() * 2 - 1;\\nif (value < 0) {\\n\\tvalue = 0;\\n} else if (value > 100) {\\n\\tvalue = 100;\\n}\\nreturn value+40;\"},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Fourth\",\"color\":\"#673ab7\",\"settings\":{},\"_hash\":0.12880275585455747,\"funcBody\":\"var value = (prevValue-50) + Math.random() * 2 - 1;\\nif (value < 0) {\\n\\tvalue = 0;\\n} else if (value > 100) {\\n\\tvalue = 100;\\n}\\nreturn value+50;\"}]}],\"timewindow\":{\"realtime\":{\"timewindowMs\":60000}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{\"borderWidth\":5,\"borderColor\":\"#fff\",\"legend\":{\"display\":true,\"labelsFontColor\":\"#666666\"}},\"title\":\"Total Error Pie\",\"dropShadow\":true,\"enableFullscreen\":true,\"titleStyle\":{\"fontSize\":\"16px\",\"fontWeight\":400}}"
      },
      "image": "data:image/png;base64,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",
      "description": "Displays latest values of the attributes or timeseries data for multiple entities in a doughnut chart. Supports numeric values only."
    }
  ]
}